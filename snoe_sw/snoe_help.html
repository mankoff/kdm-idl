<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>Extended IDL Help</TITLE>
</head>
 
<body>
<H1>Extended IDL Help</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Wed Sep 25 17:13:46 2002.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ALT_ADJUST">ALT_ADJUST</A>
<LI><A HREF="#CALC_NEW_HCI">CALC_NEW_HCI</A>
<LI><A HREF="#CART2KEPLER">CART2KEPLER</A>
<LI><A HREF="#DOY">DOY</A>
<LI><A HREF="#FILE_EXIST">FILE_EXIST</A>
<LI><A HREF="#FILE_UNIQ">FILE_UNIQ</A>
<LI><A HREF="#FIX_GAPS">FIX_GAPS</A>
<LI><A HREF="#G2M">G2M</A>
<LI><A HREF="#GRID_GLOBE">GRID_GLOBE</A>
<LI><A HREF="#L3_GLOBE">L3_GLOBE</A>
<LI><A HREF="#L3_LAT_ALT_DAY">L3_LAT_ALT_DAY</A>
<LI><A HREF="#L3_LON_LAT">L3_LON_LAT</A>
<LI><A HREF="#L4_DAY_LAT_ALT">L4_DAY_LAT_ALT</A>
<LI><A HREF="#L4_LAT_ALT_DAY">L4_LAT_ALT_DAY</A>
<LI><A HREF="#L4_LAT_ALT_DISP">L4_LAT_ALT_DISP</A>
<LI><A HREF="#LOAD_CGM">LOAD_CGM</A>
<LI><A HREF="#LOAD_LEVEL1[1]">LOAD_LEVEL1[1]</A>
<LI><A HREF="#LOAD_LEVEL1[2]">LOAD_LEVEL1[2]</A>
<LI><A HREF="#LOAD_LEVEL1_SPIN">LOAD_LEVEL1_SPIN</A>
<LI><A HREF="#LONTV">LONTV</A>
<LI><A HREF="#LONXLATE">LONXLATE</A>
<LI><A HREF="#MAG_GRID">MAG_GRID</A>
<LI><A HREF="#MAP_CONTINENTS">MAP_CONTINENTS</A>
<LI><A HREF="#MAVG">MAVG</A>
<LI><A HREF="#NEAREST_ELEMENT.PRO">NEAREST_ELEMENT.PRO</A>
<LI><A HREF="#OAMATH">OAMATH</A>
<LI><A HREF="#ORBPAR">ORBPAR</A>
<LI><A HREF="#PLOTG">PLOTG</A>
<LI><A HREF="#PLOT_CLEAR">PLOT_CLEAR</A>
<LI><A HREF="#PLOT_L1">PLOT_L1</A>
<LI><A HREF="#RAWVIEW">RAWVIEW</A>
<LI><A HREF="#RETRIEVE_UVS">RETRIEVE_UVS</A>
<LI><A HREF="#SCAT_ANG">SCAT_ANG</A>
<LI><A HREF="#SNOECT">SNOECT</A>
<LI><A HREF="#SNOE_DATE">SNOE_DATE</A>
<LI><A HREF="#SNOE_SUNPOS">SNOE_SUNPOS</A>
<LI><A HREF="#TEMPLATE">TEMPLATE</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ALT_ADJUST">
<H2>ALT_ADJUST</H2></A>
<A HREF="#CALC_NEW_HCI">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	ALT_ADJUST

 PURPOSE:
       This procedure adjust the altitude of each SNOE scan and
       calculates altitude parameters for a final fine-tune
       adjustment that may optionally be done at a later date. This
       procedure uses the MODEL to do its thang.

 CATEGORY:
       SNOE, processing

 CALLING SEQUENCE:
       This procedure should not be called by a user. It is called by
       PROC_LEVEL1

 PROCEDURE:
       see the heavily commented code

 MODIFICATION HISTORY:
       See the RCS log var
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/alt_adjust.pro)</STRONG><P>
<HR>
 
<A NAME="CALC_NEW_HCI">
<H2>CALC_NEW_HCI</H2></A>
<A HREF="#ALT_ADJUST">[Previous Routine]</A>
<A HREF="#CART2KEPLER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	CALC_NEW_HCI

 PURPOSE:
       This procedure calculates the amount to adjust the current HCI
       to target the Rayleigh peak with the UVS

 CATEGORY:
       SNOE, orbit

 CALLING SEQUENCE:
       CALC_NEW_HCI, Data

 INPUTS:
       Data:   A Level 0 Data Structure

 OUTPUTS:
       Outputs are printed:
       The mean location of the peak is printed (this should be 60)
       The error between the mean location and 60 is printed
       The number of milliseconds this error is is printed
       The number of HCI ticks of the error is printed

       If the last number is negative, the UVS should start scanning
       earlier (HCI delay shorter). If it is positive, the UVS should
       scan later (HCI delay should be longer)

 PROCEDURE:
       1) Find all leading limb spins
       2) Get the location of the MAX() of each spin
       3) Throw out everything from (2) with a max &lt; 800 (night time spins)
       4) take the mean of (3)
       5) calculate the difference with 60
       6) convert to ms units
       7) convert to HCI units

 EXAMPLE:
       RETRIEVE_UVS, 2000266, d
       calc_new_hci, d
           mean peak location (forward):       61.4414
           peak location error (60):       1.44139
           spin millisecond error:       3.48818
           HCI tick error:       1.36257

 MODIFICATION HISTORY:
       Written by: KDM; ???
       2002-09-25; KDM; added documentation

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/HCI/calc_new_hci.pro)</STRONG><P>
<HR>
 
<A NAME="CART2KEPLER">
<H2>CART2KEPLER</H2></A>
<A HREF="#CALC_NEW_HCI">[Previous Routine]</A>
<A HREF="#DOY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 ----------------------------------------------------------

 FUNCTION:

 	CART2KEPLER

 PURPOSE:

 	Converts S/C Position and velocity at a 
 	given time to an orbit ephemeris.

 CALLING SEQUENCE:

 	CART2KEPLER,r_vector,v_vector,t,MU

 INPUT PARAMETERS:

 	Postion Vector {VECTOR, x, y, z, type}:
 	x   = x component of S/C position
 	y   = y component of S/C postion
 	z   = z component of S/C position

 	Velocity Vector {VECTOR, x_dot, y_dot, z_dot, type}:
   x_dot  = x component of S/C velocity
   y_dot  = y component of S/C velocity
   z_dot  = z component of S/C velocity

 	t = Time since periapse passage when ephemeris is desired.

 	MU = Earth's gravitational constant in consitant units 
	     with position and velocity.

 OPTIONAL KEYWORD PARAMETERS:

 OUTPUT PARAMETERS:

	Structure ephemeris, containing the following parameters:
 		a           = semi-major axis
 		e           = eccentricity
 		i           = inclination
 		w           = true anomaly
 		OMEGA       = right ascension of the ascending node
 		t_periapse  = periapse passage time

 AUTHOR:

 	Jason Westphal 12/97

 ----------------------------------------------------------
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/cart2kepler.pro)</STRONG><P>
<HR>
 
<A NAME="DOY">
<H2>DOY</H2></A>
<A HREF="#CART2KEPLER">[Previous Routine]</A>
<A HREF="#FILE_EXIST">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	DOY

 PURPOSE:
       Print (or optionally return) the current UT DOY

 CATEGORY:
       SNOE, date

 CALLING SEQUENCE:
       DOY, today

 OPTIONAL OUTPUTS:
       today: contains the day-of-year of today in London

 EXAMPLE:
       To print the current doy:
          IDL&gt; DOY
       To get the current doy in a variable:
          IDL&gt; DOY, var

 MODIFICATION HISTORY:
 	Written by: KDM
	2002-09-25: KDM; Added docs
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/doy.pro)</STRONG><P>
<HR>
 
<A NAME="FILE_EXIST">
<H2>FILE_EXIST</H2></A>
<A HREF="#DOY">[Previous Routine]</A>
<A HREF="#FILE_UNIQ">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	FILE_EXIST

 PURPOSE:
       This function returns true if the requested file exists

 CATEGORY:
       SNOE, file, I/O

 CALLING SEQUENCE:
       Result = FILE_EXIST( aFileName )

 INPUTS:
       aFileName: A file name (with directory path)

 OUTPUTS:
       1 if the file exists, 0 if it does not

 RESTRICTIONS:
       No wildcards (*?)

 EXAMPLE:
       if ( file_exist( 'foo.pro' ) ) then print, &quot;foo exists!&quot;

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-07-20
	2002-09-25: KDM; added docs
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/file_exist.pro)</STRONG><P>
<HR>
 
<A NAME="FILE_UNIQ">
<H2>FILE_UNIQ</H2></A>
<A HREF="#FILE_EXIST">[Previous Routine]</A>
<A HREF="#FIX_GAPS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	FILE_UNIQ

 PURPOSE:
       Returns a uniq filename, based upon the procedure the use ran.

 CATEGORY:
       SNOE, File

 CALLING SEQUENCE:
       Result = FILE_UNIQ()

 OUTPUTS:
       A string, usabel as a filename, uniq to the current
       directory. This is the FIRST part of a filename (before the
       period). But it is unique anyways, regardless of the extension
       you should choose to add on. 

 RESTRICTIONS:
       Whatever restrictions are imposed by FINDFILE (presumably,
       read access is required in the current directory)

 PROCEDURE:
       Generate a UNIQ filename based upon the procedure that the
       user typed at the command line, regardless of how many other
       procedures were called before this one.

       Use the Procedure stack to find the TOP procedure. Generate a
       name based on it. Append a _XXXX four digit number to the
       name. Then, search for that file (with a .*) in the current
       directory.

 EXAMPLE:
       From the command line, to generate a unique filename, type:
           print, FILE_UNIQ() 
       This string is usable and unique with ANY extension.

       Call this procedure from inside some other procedures like
       this:
           SET_PLOT, 'ps'
           DEVICE, /COLOR, BITS=8, FILENAME=file_uniq()+'.ps'
       To generate a unique postscript filename.

       Here is the real beauty of this procedure: If the user runs
       &quot;L4_lat_alt_disp&quot; and this is called somewhere in it or one of
       its subroutines, the filename will start with
       L4_LAT_ALT_DISP_0000.ps, and then 0001.ps, etc... If the user
       runs it from a different procedure, it will have a different name.

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-08-29
   2002-09-01; KDM; Changed help call to use CALLS rather than /TRACEBACK

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/file_uniq.pro)</STRONG><P>
<HR>
 
<A NAME="FIX_GAPS">
<H2>FIX_GAPS</H2></A>
<A HREF="#FILE_UNIQ">[Previous Routine]</A>
<A HREF="#G2M">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	FIX_GAPS

 PURPOSE:
       This function fills in gaps in a 2D array with the average
       value of its neighbors

 CALLING SEQUENCE:
       Result = FIX_GAPS( Data )

 INPUTS:
       Data:   A 2D array of any numeric type

 OPTIONAL INPUTS:
      Gapsize: Set this value to 1 or 2 to specify the size of the
               gaps to fill in. A value of 1 means the gap must have
               2 adjacent neighbors with non Gv values. The Default
               value is 1. A value of 2 means 2 adjacent gaps will
               both get the average values of their neighbors. NOTE
               that if gapsize=2, gaps of size 1 will still be filled
               in.

      Compare: Set this to the compare function used to find the
               gaps. That is, compare should equal 'LT', 'LE', 'EQ',
               'GE', or 'GT'. The default comparitor is 'EQ'

 KEYWORD PARAMETERS:
       X:      Set this keyword to fill in gaps in the X direction

       Y:      Set this keyword to fill in gaps in the Y direction

       Gv:     Set this keyword to the value of the gaps. This value
               defaults to zero if the keyword is not set.

       Edge:   Set this keyword to have the algorithm wrap around the
               edge of the array, and fill in gaps on the edge.

 OUTPUTS:
       This procedure returns the original array, but the gaps have
       been filled in by the average of its two neighbors.

 PROCEDURE:
       A gap is defined as a value in the array that is 0 (zero) or
       equal to the value 'Gv'. Furthermore, the gap must have two
       neighbors that are *NOT* equal to Gv.

       A Neighbor is defined as the array cells to the left and right
       of a gap if the X keyword is set, or above and below if the Y
       keyword is set. 

       If the Edge keyword is set, then a cell on the edge might
       still have two valid neighbors.

 EXAMPLE:
       a = indgen( 4,4 )
       a[ [ 0,2,6,7,8,11,15 ] ] = 99
       print, fix_gaps( data, /x, /edge, gv=99 )
       print, fix_gaps( data, /y, gv=99 )

       NOTE:
       (fix_gaps(fix_gaps(d,/y),/x)) NE (fix_gaps(fix_gaps(d,/x),/y))

 MODIFICATION HISTORY:
 	Written by:	Ken Mankoff, June, 2001
       Oct, 2001       Added documentation and most keywords
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/fix_gaps.pro)</STRONG><P>
<HR>
 
<A NAME="G2M">
<H2>G2M</H2></A>
<A HREF="#FIX_GAPS">[Previous Routine]</A>
<A HREF="#GRID_GLOBE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	G2M

 PURPOSE:
       Translate from geographic to magnetic (CGM) coordinates

 CATEGORY:
       SNOE, coordinates

 CALLING SEQUENCE:
       G2M, Glat, Glon, Year, Mlat, Mlon

 INPUTS:
       Glat:   An array of latitudes. Should be in geographic
               coords. This array can be of any size and of any
               number of dimensions.
       Glon:   A vector of geographic longitudes. Must contain a
               valid number for each element in the Glat
               array. Longitudes can be either -180W to 180E, or 0E
               to 360E.
       Year:   The year to use for the CGM model

 KEYWORD PARAMETERS:
       LSHELL: Set this keyword to a variable that will contain the
               Lshell values for each [Glat,Glon] pair.

       BFIELD: Set this keyword to a variable that will contain the
               B Field Strength for each [Glat,Glon] pair.

 OUTPUTS:
       Mlat: (output) Magnetic latitudes corresponding to each
               [Glat,Glon] pair
       Mlon: (output) Magnetic longitudes corresponding to each
               [Glat,Glon] pair. Matches each Mlat value. The output
               longitudes are ALWAYS on a -180W to 180E grid.

 DEPENDENCIES:
       Uses LOAD_CGM.PRO
            RANGECIR.PRO

 EXAMPLE:
       G2M, [-90,-60,-30,0,30,60,90], [0,0,0,0,0,0,0], 1998, Mlat, Mlon
       G2M, [0], [0], 1998, Mlat, Mlon, lshell=lshell, bfield=bfield

 MODIFICATION HISTORY:
 	Written by:	Ken Mankoff, September 2001.
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/g2m.pro)</STRONG><P>
<HR>
 
<A NAME="GRID_GLOBE">
<H2>GRID_GLOBE</H2></A>
<A HREF="#G2M">[Previous Routine]</A>
<A HREF="#L3_GLOBE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	GRID_GLOBE

 PURPOSE:
   This procedure displays a 2D array onto a globe.

 CATEGORY:
   SNOE, image, display

 CALLING SEQUENCE:
   GRID_GLOBE, DATA

 INPUTS:
   DATA: A 2D FLOAT array.

 OPTIONAL INPUTS:
   None
	
 KEYWORD PARAMETERS:
   LAT:   The center latitude of the image [ 0 ]
   LONG:  The center longitud of the image [ 0 ]
   LV:    The MAX (Large Value) to scale the data with [ max( data ) ]
   SV:    The MIN (Small Value) to scale the data with (only used
          with LOG) [ LV / 20. ]
   CONTINENTS: Set this keyword to draw the continents
   GGRID: Set this keyword to draw a Geographic grid
   MGRID: Set this keyword to draw a Magnetic grid
   CCOLOR:The colortable index of the Continents [ 0 ]
   GCOLOR:The colortable index of the Geo Grid [ 0 ]
   MCOLOR:The colortable index of the Mag Grid [ 255 ]
   LOG:   Set this kewyord to image the log of the data
   ROT:   Set this keyword to the number of degrees to rotate the globe
   XSIZE: Xsize of the image (pixels) [ 400 ]
   YSIZE: Ysize of the image (pixels) [ 400 ]
   PS:    Set this keyword to produce a Postscript image
   EPS:   Set this keyword to produce a Encapsulated Postscript image
   GIF:   Set this keyword to produce a GIF image
   FILENAME: The name of the output file (no extension) [ gg5.* ]
   NOX:   Set this keyword to NOT display the image to X

   _EXTRA is used for the following routines:
      MAP_SET, MAP_IMAGE, MAP_CONTINENTS, MAP_GRID, MAG_GRID,
      LOAD_CGM, DEVICE, PLOTS, and possibly others...

 OUTPUTS:
   An image

 SIDE EFFECTS:
   Modifies the !MAP system variable.
   Modifies the Z buffer
   Modifies the DEVICE setting if /PS or /EPS set

 RESTRICTIONS:
   None known

 PROCEDURE:
   See MAP_SET and &quot;MAP_PROJECTIONS&quot; in the IDL documentation.

 EXAMPLE:
   To get a first brief look at the data, use the following code,
   which produces a cylindrica projection with the continents for
   reference.
        
             GRID_GLOBE, data, /cont

   To produce a globe centered on the North Magnetice Pole,
   orthographic projection, with geographic grid, magnetic grid, and
   continents drawn on ... And produce output in both GIF and PS
   format (named 'test.gif' and 'test.ps' respectively), with the
   data BILINEARLY smoothed ... And the continents drawn thick, and
   the auroral oval drawn VERY thick, and the continents drawn in
   BLUE (index 10 in the SNOE color table), use this code:

             GRID_GLOBE, data, lat=81.5, long=277.5, /ortho, /gg,
             /mg, /cont, /PS, /GIF, fname='test', /BILINEAR,
             MLINETHICK=2, OVAL=4, CCOLOR=10

 MODIFICATION HISTORY:
 	Written by:	KDM, 1998 - 2001
   2002-07-23. KDM. Added documentation. Modified to run on the 24 bit
                    displays at GI. Cleaned up code. Put into RCS.
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/grid_globe.pro)</STRONG><P>
<HR>
 
<A NAME="L3_GLOBE">
<H2>L3_GLOBE</H2></A>
<A HREF="#GRID_GLOBE">[Previous Routine]</A>
<A HREF="#L3_LAT_ALT_DAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	L3_GLOBE

 PURPOSE:
   Display a globe of 1 day of SNOE data

 CATEGORY:
   SNOE, image, map, display

 CALLING SEQUENCE:
   L3_GLOBE, Coords, Yyyyddd, Yyyyddd1

 INPUTS:
   COORDS: The coordinate system of dataset to use ('geo' or 'mag')
   YYYYDDD: The date of the data to display
   
 OPTIONAL INPUTS:
   YYYYDDD1: The end date if in automatic movie mode
	
 KEYWORD PARAMETERS:
   FILL: Set this keyword to fill in some holes using FIX_GAPS
   MASK: Set this keyword to mask out the polar regions (80 to the pole)
   MANUAL: Set this to control the movie manually.
           ',': previous day (&lt;)
           'l': toggle Log mode
           'j': Jump to YYYYDDD
           'q': Quit movie mode
           any other key: next day
 
   _EXTRA is used by:
       L3_LON_LAT: altitude, verbose
       GRID_GLOBE, lots (see documentation)
       MAP_SET, MAP_GRID, MAG_GRID, LOAD_CGM, etc.

 OUTPUTS:
   An image

 SIDE EFFECTS:
   Uses current WINDOW. May change PS device.

 RESTRICTIONS:
   Must be in directory with L3 files (NO_?_den_???.dat)

 EXAMPLE:
   Simple view of a day:
   L3_GLOBE, 'geo', 1998124

   Nice hard-copy output
   L3_globe,'geo',1998124,/ortho,lat=81.5,long=277.5,/mask,/cont,/gg,
             /mg,/bil,lv=!SNOE.f.l3_lv,/ps,filename='test'

 MODIFICATION HISTORY:
 	Written by:	KDM; 2002-07-26
   2002-09-12; KDM; Fixed bug when /MANUAL set. Added STATUSLINE output

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/l3_globe.pro)</STRONG><P>
<HR>
 
<A NAME="L3_LAT_ALT_DAY">
<H2>L3_LAT_ALT_DAY</H2></A>
<A HREF="#L3_GLOBE">[Previous Routine]</A>
<A HREF="#L3_LON_LAT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	L3_LAT_ALT_DAY

 PURPOSE:
   This routine displays one orbit of L3 data at a time. A movie can be
   generated, or a single day, or a PS file. You can step through the
   data orbit-by-orbit, or day-by-day but only for a given orbit.

 CATEGORY:
   SNOE, image, movie

 CALLING SEQUENCE:
   L3_LAT_ALT_DAY, Coord, YYYYDDD YYYYDDD1

 INPUTS:
   COORD: The coordinate system of the data, either 'geo' or 'mag'
   YYYYDDD: The day to display.

 OPTIONAL INPUTS:
   YYYYDDD1: The last day to display in a MOVIE sequence
	
 KEYWORD PARAMETERS:
   ORBIT: Set this to the orbit number to view (0 through 15) if you
       want to see 1 orbit per day. If not set, all orbits are viewed.
   MANUAL: Set this to control the movie manually
           ,: prev day (&lt;)
           q: Quit movie
           j: Jump to day
           l: Toggle LOG mode
           any other key: next day
   LV: The large value of the data [ !SNOE.f.L3_lv ]
   SV: The small value of the data [ lv / 20. ] used with /LOG only
   PS: Set this keyword to produce a POSTSCRIPT image
   CH: Set this to the desired channel to view [ 2 ]
   LOG: Set this if the log of the data should be imaged
   MASK: Set this to mask out part of the data (PMCs)

   EXTRA=e is used for:
       IMDISP: (INTERP, OUT_POS, etc. )
       DEVICE: (FILENAME, BITS_PER_PIXEL, PORTRAIT, LANDSCAPE, etc. )
       others...

 OUTPUTS:
   An image, or a PS file

 SIDE EFFECTS:
   Uses the PS device if /PS set. Uses the current WINDOW

 RESTRICTIONS:
   Must be in a L3-type directory (needs NO_?_den_???.dat)

 EXAMPLE:
   To generate an image:
   L3_lat_alt_day, 'geo', 1998079
   L3_lat_alt_day, 'mag', 2002150, /LOG, /PS, /INTERP, FILENAME='foo.ps'

   To watch a movie:
   L3_lat_alt_day, 'geo', 1998079, 1999079, /LOG
   L3_lat_alt_day, 'geo', 1998079, 1999079, /LOG, ORBIT=7
   
   To step through:
   L3_lat_alt_day, 'geo', 1998079, /MANUAL
   L3_lat_alt_day, 'geo', 1998079, ORBIT=0, /MANUAL

 MODIFICATION HISTORY:
   Written by: KDM; 2002-07-26
   KDM; 2002-08-21; Fixed orbit movie bug
   KDM; 2002-08-29; Fixed altitude axis error. Made tickv
                    exact. Changed title. Fixed linear CBAR 
   KDM; 2002-09-01; /swap_if_big_endian
   KDM; 2002-09-09; added _EXTRA=e to OPENR
   KDM; 2002-09-18; handles L3 files with 16 orbits per day
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/l3_lat_alt_day.pro)</STRONG><P>
<HR>
 
<A NAME="L3_LON_LAT">
<H2>L3_LON_LAT</H2></A>
<A HREF="#L3_LAT_ALT_DAY">[Previous Routine]</A>
<A HREF="#L4_DAY_LAT_ALT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	L3_LON_LAT

 PURPOSE:
       This procedure opens the L3 files, and returns one days worth
       of data in a regularly gridded lon/lat array

 CATEGORY: SNOE, Database

 CALLING SEQUENCE:
       L3_LON_LAT, coords, yyyyddd, data, altitude=altitude

 INPUTS:
       coords:  'geo' or 'mag'
       yyyyddd: the date of the data to return

 KEYWORD PARAMETERS:
       ALTITUDE: Set this to the altitude (in kilometers) to
       use. Defaults to 106km.

 OUTPUTS:
       data: An array

 PROCEDURE:
	You can describe the foobar superfloatation method being used here.
	You might not need this section for your routine.

 EXAMPLE:
       L3_LON_LAT, 'geo', 1998079, d, alt=106

 MODIFICATION HISTORY:
   Written by:	CAB; 1999.
   2002-09-01: KDM; /swap_if_big_endian, partial documentation
   2002-09-09; KDM; added _EXTRA=e to OPEN

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/l3_lon_lat.pro)</STRONG><P>
<HR>
 
<A NAME="L4_DAY_LAT_ALT">
<H2>L4_DAY_LAT_ALT</H2></A>
<A HREF="#L3_LON_LAT">[Previous Routine]</A>
<A HREF="#L4_LAT_ALT_DAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	L4_DAY_LAT_ALT

 PURPOSE:
   This routine displays a keogram (x=time, y=lat) of L4 data.

 CATEGORY:
   SNOE, image

 CALLING SEQUENCE:
   L4_DAY_LAT_ALT_DAY, Coord, YYYYDDD0, YYYYDDD1

 INPUTS:
   COORD: The coordinate system of the data, either 'geo' or 'mag'
   YYYYDDD0: The start date
   YYYYDDD1: The stop  date

 KEYWORD PARAMETERS:
   LV: The large value of the data [ !SNOE.f.l4_lv ]
   SV: The small value of the data [ lv / 20. ] used with /LOG only
   PS: Set this keyword to produce a POSTSCRIPT image
   CH: Set this to the desired channel to view [ 2 ]
   LOG: Set this if the log of the data should be imaged
   ALTITUDE: The altitude plane (in km) to use for the image
   FIX: Set this to linear interpolate over gaps of size 2 or
             less in the X direction

   EXTRA=e is used for:
       IMDISP: (INTERP, OUT_POS, etc. )
       DEVICE: (FILENAME, BITS_PER_PIXEL, PORTRAIT, LANDSCAPE, etc. )
       others...

 OUTPUTS:
   An image, or a PS file

 SIDE EFFECTS:
   Uses the PS device if /PS set. Uses the current WINDOW

 RESTRICTIONS:
   Must be in a L4-type directory (needs NO_?_day_???.dat)

 EXAMPLE:
   To generate an image:
   L4_day_lat_alt_day, 'geo', 1998079, 1999079
   L4_day_lat_alt_day, 'mag', 1998070, 2002150, /LOG, /PS, /INTERP, $

 MODIFICATION HISTORY:
   Written by: KDM; 2002-07-26
   KDM; 2002-08-27; yrange now represents latitude exactly [92.5]
   KDM; 2002-09-01; /swap_if_big_endian    
   KDM; 2002-09-02; Added FIX keyword, and fixed xaxis tick values
   KDM; 2002-09-10; Added _EXTRA=e to OPENR for any-endian usability
   KDM; 2002-09-13; Fix: cbar text was wrong color in PS

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/l4_day_lat_alt.pro)</STRONG><P>
<HR>
 
<A NAME="L4_LAT_ALT_DAY">
<H2>L4_LAT_ALT_DAY</H2></A>
<A HREF="#L4_DAY_LAT_ALT">[Previous Routine]</A>
<A HREF="#L4_LAT_ALT_DISP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	L4_LAT_ALT_DAY

 PURPOSE:
   This routine displays one day of L4 data at a time. A movie can be
   generated (manual or passive mode), or a single day, or a PS file.

 CATEGORY:
   SNOE, image, movie

 CALLING SEQUENCE:
   L4_LAT_ALT_DAY, Coord, YYYYDDD [YYYYDDD1]

 INPUTS:
   COORD: The coordinate system of the data, either 'geo' or 'mag'
   YYYYDDD: The day to display.

 OPTIONAL INPUTS:
   YYYYDDD1: The last day to display in a MOVIE sequence
	
 KEYWORD PARAMETERS:
   MANUAL: Set this to control the movie manually
           ,: prev day (&lt;)
           q: Quit movie
           j: Jump to day
           l: Toggle LOG mode
           any other key: next day
   PS: Set this keyword to produce a POSTSCRIPT image
   CH: Set this to the desired channel to view [ 2 ]
   LOG: Set this to view the data on a Logarithmic scale

   EXTRA=e is used for:
       L4_LAT_ALT_DISP (lv, sv, mask, log, subtitle, interp, xtitle, etc.)
       IMDISP: (INTERP, OUT_POS, etc. )
       DEVICE: (FILENAME, BITS_PER_PIXEL, PORTRAIT, LANDSCAPE, etc. )
       others...

 OUTPUTS:
   An image, or a PS file

 SIDE EFFECTS:
   Uses the PS device if /PS set. Uses the current WINDOW

 RESTRICTIONS:
   Must be in a L4-type directory (needs NO_?_day_???.dat)

 PROCEDURE:
   This routine just opens files and handles the movie part
   (i.e. moving through the file in a loop or based upon your
   keystrokes). The display program is called each time through the
   loop, with all necessary variables and keywords (and _EXTRA=e)
   passed in.

 EXAMPLE:
   To generate an image:
   L4_lat_alt_day, 'geo', 1998079
   L4_lat_alt_day, 'mag', 2002150, /LOG, /PS, /INTERP, FILENAME='foo.ps'

   To watch a movie:
   L4_lat_alt_day, 'geo', 1998079, 1999079, /LOG
   
   To step through:
   L4_lat_alt_day, 'geo', 1998079, /MANUAL, /INTERP

 MODIFICATION HISTORY:
   Written by: KDM; 2002-07-25
   2002-07-26: KDM; Added TOGGLE LOG mode
   2002-08-27; KDM; Improved AXIS accuracies
   2002-08-29; KDM; cm-3 should be cm^3
   2002-08-29; KDM; Now uses generic L4_LAT_ALT_DISP subroutine for
                    graphics. Uses FILE_UNIQ() 
   2002-09-01; KDM; /swap_if_big_endian
   2002-09-09; KDM; added _EXTRA=e to OPEN (can now be used with BIG ENDIAN)
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/l4_lat_alt_day.pro)</STRONG><P>
<HR>
 
<A NAME="L4_LAT_ALT_DISP">
<H2>L4_LAT_ALT_DISP</H2></A>
<A HREF="#L4_LAT_ALT_DAY">[Previous Routine]</A>
<A HREF="#LOAD_CGM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	L4_LAT_ALT_DISP

 PURPOSE:
   This routine displays one day of L4-formatted data at a time. This
   means you create an array however you want that is analagous to
   the L4 data, and then pass it to this procedure for display

 CATEGORY:
   SNOE, image

 CALLING SEQUENCE:
   L4_LAT_ALT_DISP, Data

 INPUTS:
   DATA: An array, FLTARR( 37, 28 )
         This is the size of the DATA section of L4 (not bookkeepping)

 OPTIONAL INPUTS:
   none
	
 KEYWORD PARAMETERS:
   LV: The large value of the data [ !SNOE.f.l4_lv ]
   SV: The small value of the data [ lv / 20. ] used with /LOG only
   PS: Set this keyword to produce a POSTSCRIPT image
   LOG: Set this if the log of the data should be imaged
   MASK: Set this to mask out part of the data (PMCs)
   SUBTITLE: A subtitle (in the image) to display

   EXTRA=e is used for:
       IMDISP: (INTERP, OUT_POS, etc. )
       DEVICE: (FILENAME, BITS_PER_PIXEL, PORTRAIT, LANDSCAPE, etc. )
       others...

 OUTPUTS:
   An image, or a PS file

 SIDE EFFECTS:
   Uses the PS device if /PS set. Uses the current WINDOW

 RESTRICTIONS:
   Must be in a L4-type array (data, not bookkeeping)

 EXAMPLE:
   To generate an image:
   L4_lat_alt_disp, data
   L4_lat_alt_disp, data, /LOG, /PS, /INTERP, FILENAME='foo.ps'

   DATA:
   openr, lun, 'NO_2_day_geo.dat', /GET
   data = assoc( lun, !SNOE.f.l4 )
   data = data[ 9 ]             ; day 1998079
   data = data[ 0:36, 0:27 ]    ; trim off bookkeepping

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-08-10
       2002-08-29; KDM; Fixed Altitude scale error. Made tickv
                        exact. Fixed title (cm^3, not cm-3). 
                        Added PS. Now uses FILE_UNIQ()

       
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/l4_lat_alt_disp.pro)</STRONG><P>
<HR>
 
<A NAME="LOAD_CGM">
<H2>LOAD_CGM</H2></A>
<A HREF="#L4_LAT_ALT_DISP">[Previous Routine]</A>
<A HREF="#LOAD_LEVEL1[1]">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   LOAD_CGM

 PURPOSE:
   This procedure loads the Correctd Geomagnetic Grid (CGM) for all
   latitude and longitudes for a given year. The grid can be binned
   on geomagnetic or geographic. Also returned are LSHELL and Bz.

 CATEGORY:
   SNOE, mapping, coordinates, magnetic

 CALLING SEQUENCE:
   LOAD_CGM, Data

 INPUTS:
   None

 OPTIONAL INPUTS:
   None

 KEYWORD PARAMETERS:
   YEAR: Set this to the year of the CGM model to use 
         [ VALID: 1998 through 2002 ]
         [ DEFAULT: 1999 ]
   GRID: Set this to the grid that the data should be binned on 
         [ VALID: 'geo' or 'mag' ]
         [ DEFAULT: 'geo' ]
   B_ONLY: Set this keyword to only return the magnetic field strength
   SNOE_COORDS: Set this keyword to return the data on the SNOE
     coordinate system (-180 to 180 longitude, rather than 0 to 360)

 OUTPUTS:
   Data: This procedure returns an array of geographic latitude,
     longitude, geomagnetic latitude, longitude, Bz (magnetic field
     strength), and Lshell, gridded on the requested coordinate
     systems. 

     The data array returned is a FLTARR( 361, 181, 6 ).
     The 3rd dimension is [ gLat, gLon, mLat, mLon, Lshell, Bz ]
     Each of these is FLTARR( 361 lon, 181 ), or (Lat,Lon).
     The longitudes run from 0 to 360 or -180 to 180 if /SNOE_COORDS set
     **The latitudes run from -90 to 90. Up-side down.**

     Lat having 360 and Lon having 180 is counter-intuitive, but
     think of it this way: The latitude ring on the globe at the
     equator has 360 possible longitude values. A longitude column
     on a globe has only 180 possible values. See the EXAMPLES
     section, maybe it will help.

 RESTRICTIONS:
   Requires the CGM datasets (in !snoe.p.base+'other/CGM/')

 PROCEDURE:
   * See code.
   * http://nssdc.gsfc.nasa.gov/space/cgm/cgm.html
   * http://nssdc.gsfc.nasa.gov/space/model/models/igrf.html
     This websites have interactive ways to test and verify the data.

 EXAMPLE:
   LOAD_CGM, data
   LOAD_CGM, data, year=1999, grid='mag', /SNOE

   To print the geographic coordinates of the geomagnetic north pole:
   LOAD_CGM, data, grid='mag'
   print, data[ 180, 90+90, 0:3 ] ;;; = [glat,glon,mlat,mlon] @ [90,0] magn

   To print the geographic coordinates of the geomagnetic south pole:
   LOAD_CGM, data, grid='mag'
   print, data[ 180, 90-90, 0:1 ] ;;; = [glat,glon,mlat,mlon] @ [-90,0] magn

   To print the magnetic coordinates of Boulder (40N, 105W):
   LOAD_CGM, data, grid='geo'
   print, data[ 105, 90+40, [2,3] ]

 MODIFICATION HISTORY:
 	Written by:	Ted Fisher, 2000.
   2002-07-23; KDM; Added documentation
   2002-07-25; KDM; Switched path to !SNOE.p.base
   2002-09-18; KDM; Switched to /SWAP_IF_LITTLE_ENDIAN so its portable
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/load_cgm.pro)</STRONG><P>
<HR>
 
<A NAME="LOAD_LEVEL1[1]">
<H2>LOAD_LEVEL1[1]</H2></A>
<A HREF="#LOAD_CGM">[Previous Routine]</A>
<A HREF="#LOAD_LEVEL1[2]">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	LOAD_LEVEL1

 PURPOSE:
       Load a day of Level One Data

 CATEGORY:
	Put a category (or categories) here.  For example:
	SNOE, Imaging, Map, Orbit, Foo

 CALLING SEQUENCE:
	Write the calling sequence here. Include only positional parameters
	(i.e., NO KEYWORDS). For procedures, use the form:

	ROUTINE_NAME, Parameter1, Parameter2, Foobar

	Note that the routine name is ALL CAPS and arguments have Initial
	Caps.  For functions, use the form:
 
	Result = FUNCTION_NAME(Parameter1, Parameter2, Foobar)

	Always use the &quot;Result = &quot; part to begin. This makes it super-obvious
	to the user that this routine is a function!

 INPUTS:
	Parm1:	Describe the positional input parameters here. Note again
		that positional parameters are shown with Initial Caps.

 OPTIONAL INPUTS:
	Parm2:	Describe optional inputs here. If you don't have any, just
		delete this section.
	
 KEYWORD PARAMETERS:
	KEY1:	Document keyword parameters like this. Note that the keyword
		is shown in ALL CAPS!

	KEY2:	Yet another keyword. Try to use the active, present tense
		when describing your keywords.  For example, if this keyword
		is just a set or unset flag, say something like:
		&quot;Set this keyword to use foobar subfloatation. The default
		 is foobar superfloatation.&quot;

 OUTPUTS:
	Describe any outputs here.  For example, &quot;This function returns the
	foobar superflimpt version of the input array.&quot;  This is where you
	should also document the return value for functions.

 OPTIONAL OUTPUTS:
	Describe optional outputs here.  If the routine doesn't have any, 
	just delete this section.

 COMMON BLOCKS:
	BLOCK1:	Describe any common blocks here. If there are no COMMON
		blocks, just delete this entry.

 SIDE EFFECTS:
	Describe &quot;side effects&quot; here.  There aren't any?  Well, just delete
	this entry.

 RESTRICTIONS:
	Describe any &quot;restrictions&quot; here.  Delete this section if there are
	no important restrictions.

 PROCEDURE:
	You can describe the foobar superfloatation method being used here.
	You might not need this section for your routine.

 EXAMPLE:
	Please provide a simple example here. An example from the PICKFILE
	documentation is shown below. Please try to include examples that
       do not rely on variables or data files that are not defined in
       the example code. Your example should execute properly if typed
       in at the IDL command line with no other preparation.

	Create a PICKFILE widget that lets users select only files with 
	the extensions 'pro' and 'dat'.  Use the 'Select File to Read' title 
	and store the name of the selected file in the variable F.  Enter:

		F = PICKFILE(/READ, FILTER = ['pro', 'dat'])

 MODIFICATION HISTORY:
 	Written by:	Your name here, Date.
	2002-03-30: XYZ Made a change. Remember to change the stuff above 
			if you add a new keyword or something!

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/load_level1.pro)</STRONG><P>
<HR>
 
<A NAME="LOAD_LEVEL1[2]">
<H2>LOAD_LEVEL1[2]</H2></A>
<A HREF="#LOAD_LEVEL1[1]">[Previous Routine]</A>
<A HREF="#LOAD_LEVEL1_SPIN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	LOAD_LEVEL1

 PURPOSE:
       Load a day of Level One Data

 CATEGORY:
       SNOE, Database

 CALLING SEQUENCE:
       LOAD_LEVEL1, Yyyyddd, ch1, ch2

 INPUTS:
       Yyyyddd: The year and day of year of the data to load

 OUTPUTS:
       CH1: The data for the requested day from channel 1
       CH2: see CH1

 EXAMPLE:
       To get the first days worth of data:
          IDL&gt; load_level1, 1998070, ch1, ch2
       See level1/README.file_format to understand the outputs

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-09-??
	2002-09-25: KDM; Added docs
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/load_level1.pro)</STRONG><P>
<HR>
 
<A NAME="LOAD_LEVEL1_SPIN">
<H2>LOAD_LEVEL1_SPIN</H2></A>
<A HREF="#LOAD_LEVEL1[2]">[Previous Routine]</A>
<A HREF="#LONTV">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	LOAD_LEVEL1_SPIN

 PURPOSE:
       This procedure loads 1 spin from level1. Useful in a loop

 CATEGORY:
       SNOE, database, processing, analysis

 CALLING SEQUENCE:
       LOAD_LEVEL1_SPIN, yyyy, ddd, orb, spin, data, ch=ch

 INPUTS:
       YYYY:   The year the spin is in
       DDD:    The day of year of the spin
       ORB:    The orbit the spin is in
       SPIN:   The number in the orbit of the spin

 KEYWORD PARAMETERS:
       CH:     The channel of the spin [ required ]

 OUTPUTS:
       Data: The spin

 OPTIONAL OUTPUTS:
       lat, lon, mlat, mlon, sza, sca, lshell, bfield, ut, hci, rval, clean

 EXAMPLE:
       To load the first spin used in the SNOE dataset,
          load_level1_spin, 1998, 070, 0, 0, data, ch=1

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-08-??
	2002-09-25: KDM; added documentation

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/load_level1_spin.pro)</STRONG><P>
<HR>
 
<A NAME="LONTV">
<H2>LONTV</H2></A>
<A HREF="#LOAD_LEVEL1_SPIN">[Previous Routine]</A>
<A HREF="#LONXLATE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	LONTV

 PURPOSE:
       Fix a lat/lon grid that you want to map on a globe with
       MAP_PATCH or MAP_IMAGE so it works with IDLs buggy routines

 CATEGORY:
       SNOE, Imaging, Map

 CALLING SEQUENCE:
       Result = LONTV( Array )

 INPUTS:
       Array: An array of any size, where the X dimension is
           longitude, and Y is data

 OUTPUTS:
       The array is returned with the first column duplicated as the
       last column.

 EXAMPLE:
     test = REBIN( BYTSCL( BINDGEN(15) ), 15, 2 )
     tv, map_image( test, bilinear=0 )
     ;;; The max color is 1/2 as wide as all the rest!
     tv, map_image( lontv(test), bilinear=0 )

 MODIFICATION HISTORY:
 	Written by: Barth
	2002-09-25: Added docs

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/lontv.pro)</STRONG><P>
<HR>
 
<A NAME="LONXLATE">
<H2>LONXLATE</H2></A>
<A HREF="#LONTV">[Previous Routine]</A>
<A HREF="#MAG_GRID">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	LONXLATE

 PURPOSE:
   This function translates an array (or atomic element) of
   longitudes from one grid to another. A grid is either Eastern or
   Western longitude, and from 0 to 360 or -180 to 180

 CATEGORY:
   Mapping

 CALLING SEQUENCE:
   Result = LONXLATE( Longitudes, /from_xxx, /to_xxx )

 INPUTS:
   Longitudes: An array (or a atomic element (scalar)) of
   longitudes. These must be valid regarding the /FROM_xxx grid
   system. 

 KEYWORD PARAMETERS:
   FROM_180E: A keyword specifying that the longitude(s) range
   between -180 and 180, and increase to the East.

   FROM_180W: A keyword specifying that the longitude(s) range
   between -180 and 180, and increase to the West.

   FROM_360E: A keyword specifying that the longitude(s) range
   between 0 and 360, and increase to the East.

   FROM_360W: A keyword specifying that the longitude(s) range
   between 0 and 360, and increase to the West.

   TO_180E: A keyword specifying that the output longitude(s) range
   should be between -180 and 180, and increase to the East.

   TO_180W: A keyword specifying that the output longitude(s) range
   should be between -180 and 180, and increase to the West.

   TO_360E: A keyword specifying that the output longitude(s) range
   should be between 0 and 360, and increase to the East.

   TO_360W: A keyword specifying that the output longitude(s) range
   should be between 0 and 360, and increase to the West.

 OUTPUTS:
   This function returns the input longitude array, translated from
   the grid specified by the /FROM_xxx keyword, onto the grid
   specified by the /TO_xxx keyword.

 SIDE EFFECTS:
   None that I know of yet... Email me if you find any.

 RESTRICTIONS:
   The input array must be valid on the grid specified by the
   /FROM_xxx keyword. No error checking is done. Use CIRRANGE and/or
   RANGECIR before calling this to fix your lons for you (they are in
   the astronomy library)

 PROCEDURE:
   * read the code
   * Most of the work is done in the /to_180e section. All other
   /TO_xxx keywords use that chunk of code, pass in the /FROM_xxx
   keyword, and then do only a little bit of work to translate from
   /to_180e to the actual requested /TO_xxx.

 EXAMPLE:
   lon_0 = [ -135, -45, 45, 135 ]
   lon_1 = lonxlate( lon_0, /from_180e, /to_180w )
   lon_2 = lonxlate( lon_1, /from_180w, /to_360e )

 MODIFICATION HISTORY:
 	Written by:	Ken Mankoff (mankoff@lasp.colorado.edu), 2002-04-03
	2002-05-22; KDM; Added documentation.
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/lonxlate.pro)</STRONG><P>
<HR>
 
<A NAME="MAG_GRID">
<H2>MAG_GRID</H2></A>
<A HREF="#LONXLATE">[Previous Routine]</A>
<A HREF="#MAP_CONTINENTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	MAG_GRID

 PURPOSE:
       Return a magnetic grid warped to the current map projection,
       that can be overlayed on an image.

 CATEGORY:
       SNOE, image, mapping

 CALLING SEQUENCE:
       result = mag_grid()

 INPUTS:
       NONE

 OPTIONAL INPUTS:
       NONE

 KEYWORD PARAMETERS:
       HIRES:  Set this keword equal to one (1) to produce a high
               quality grid. This may take some time (less than a
               minute). The default is a low quality (but quick)
               image

       MAGTHICK: Set this to the line thickness desired.

       OVAL:   Set this to the thickness desired for the auroral oval
               grid lines (i.e. the 60 and 70 degree latitude lines)

       LATDEL, LONDEL: See MAP_GRID documentation

 OUTPUTS:
       This function returns a bytescaled image. The size is the size
       of the current device. The array returned contains the value 1
       where the field lines are, and 0 everywhere else.

 SIDE EFFECTS:
       NONE known

 RESTRICTIONS:
       Must call map_set before this function
       Requires mag_grid.pro

 PROCEDURE:
       This function warps a CGM magnetic lookup table (LUT) onto the
       current map projection. Since our LUTs are at a 1 degree
       resolution, the quality of the lines is poor. Hence the /HIRES
       keyword. The algorithm is the same in this case, but the image
       is created much larger (approx 20 times), and then shrunk
       down. The result is a higher quality image.

 EXAMPLE:

        ;;; set up and display the data
        MAP_SET, 88.5, 277.5, /cyl, /iso
        TV, MAP_IMAGE( data, xx, yy ), xx, yy
        img = TVRD()

        ;;; get the grid for the above map_set projection
        grid0 = MAG_GRID()
        grid1 = MAG_GRID( /HIRES, YEAR=2000, magthick=2, oval=4 )

        ;;; overlay grid on image, and display
        magGridColor = 255
        img[ WHERE( grid1 EQ 1 ) ] = magGridColor
        TV, img

 MODIFICATION HISTORY:
 	Written by:	Ted Fisher, Summer 2000
       Oct, 2001       TAF: made lots of misc usability improvements
       Oct, 2001       KDM: added documentation, removed xysize
       Jul, 2002       KDM: Removed YEAR keyword. LOAD_CGM has
                            own. Uses _EXTRA=e

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/mag_grid.pro)</STRONG><P>
<HR>
 
<A NAME="MAP_CONTINENTS">
<H2>MAP_CONTINENTS</H2></A>
<A HREF="#MAG_GRID">[Previous Routine]</A>
<A HREF="#MAVG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       MAP_CONTINENTS

 PURPOSE:
       The MAP_CONTINENTS procedure draws continental boundaries,
 filled continents, political boundaries, coastlines, and/or rivers,
 over an existing map projection established by MAP_SET. Outlines can
 be drawn in low or high-resolution (if the optional high-resolution
 CIA World Map database is installed). If MAP_CONTINENTS is called
 without any keywords, it draws low-resolution, unfilled continent
 outlines.

 MAP_SET must be called before MAP_CONTINENTS to establish the
 projection type, the center of the projection, polar rotation
 and geographic limits.

 Keywords not recognized are passed along in _EXTRA to PLOTS and/or
 POLYFILL depending on options requested.

 CATEGORY:
              MAPPING

 CALLING SEQUENCE:
              MAP_CONTINENTS

 INPUTS:
              NONE

 INPUT KEYWORD PARAMETERS:
 COASTS -- Set this keyword to draw coastlines, islands, and lakes instead of
           the default continent outlines. Note that if you are using the
           low-resolution map database (if the HIRES keyword is not set), many
           islands are drawn even when COASTS is not set. If you are using the
           high-resolution map database (if the HIRES keyword is set),
           no islands are drawn unless COASTS is set.

 COLOR -- The color index of the lines being drawn.

 CONTINENTS:  Set this keyword to plot the continental boundaries.
       This is the default.
       Note that if you are using the low-resolution map database
       (if the HIRES keyword is not set), outlines for continents, islands,
       and lakes are drawn when the CONTINENTS keyword is set. If
       you are using the high-resolution map database (if the HIRES keyword
       is set), only continental outlines are drawn when the CONTINENTS
       keyword is set. To draw islands and lakes when using the
       high-resolution map database, use the COASTS keyword.

 COUNTRIES -- Set this keyword to draw political boundaries as of 1993.
 _EXTRA -- Other keywords passed along to PLOTS/POLYFILL depending on
           options selected. Note that command line keywords (like
           MLINETHICK) will take precedence over options specified with
           _EXTRA or their natural names (like THICK).
 FILL_CONTINENTS -- Set this keyword to 1 to fill continent boundaries with
                    a solid color. The color is set by the COLOR keyword.
                    Set this keyword to 2 to fill continent boundaries with a
                    line fill. For line filling, the COLOR, MLINESTYLE,
                    MLINETHICK, ORIENTATION, and SPACING keywords can be used
                    to control the type of line fill. Any option valid for
                    polyfill can also be used (i.e. PATTERN).

 HIRES -- Set this keyword to use high-resolution map data instead of the
          default low-resolution data. This option is only available if you
          have installed the optional high-resolution map datasets. If the
          high-resolution data is not available, a warning is printed and
          the low-resolution data is used instead.

          This keyword can be used in conjunction with the COASTS, COUNTRIES,
          FILL_CONTINENTS, and RIVERS keywords.

 LIMIT: Set this keyword to a four-element vector
        [Lat min, Lon min, Lat max, Lon max ] to only plot continents that
        pass through the LIMIT rectangle.
        The points (Lat min, Lon min ) and (Lat max, Lon max ) are
        the latitudes and longitudes of two points diagonal from each other
        on the region’s boundary.
        The default is to use the limits from the current map projection.

     Note - Line segments for continents which extend outside of the
        LIMIT rectangle will still be plotted.

 MLINESTYLE -- The line style of the boundaries being drawn.
               The default is solid lines.
 MLINETHICK -- The thickness of the boundary or fill lines.
               The default thickness is 1.
 ORIENTATION -- Set this keyword to the counterclockwise angle in degrees
                from horizontal that the line fill should be drawn. The
                default is 0. This keyword only has effect if the
                FILL_CONTINENTS keyword is set to 2.
 RIVERS  -- Set this keyword to draw rivers.
 SPACING -- Set this keyword to the spacing, in centimeters, for a line fill.
            This keyword only has effect if the FILL_CONTINENTS keyword is
            set to 2. The default is 0.5 centimeters.

 T3D: Set this keyword to indicate that the generalized transformation
      matrix in !P.T is to be used. If not present, the user-supplied
      coordinates are simply scaled to screen coordinates.

 USA -- Set this keyword to draw borders for each state in the United States
        in addition to continental boundaries.

 ZVALUE: Sets the Z coordinate, in normalized coordinates in the
         range of 0 to 1, at which to output the continents.

      Note - This keyword has effect only if keyword T3D is set and the
         transformation is stored in !P.T

 OUTPUT KEYWORD PARAMETERS:
              NONE

 OUTPUTS:
       Draws continents, etc. over the current map display.

 COMMON BLOCKS:
       None.

 SIDE EFFECTS:
       None.

 RESTRICTIONS:
       See DESCRIPTION.

 DESCRIPTION:
       See PURPOSE.

 EXAMPLES:

         Draw Low-Resolution continents, with high resolution
         political boundaries.

         MAP_SET
         MAP_CONTINENTS
         MAP_CONTINENTS,/hires,/countries

 DEVELOPMENT NOTES:
         This version uses !type=3 and uses the NEW (IDL5) map software.
         requires map_struct_append in map_set.pro

 MODIFICATION HISTORY:
         SVP, 11/96 ;  Added header template.
         KDM, 05/01 ;  Now works with cmagnetic keyword
                       NOTE: magnetic files are in custom dir, not
                       IDL distrobution directory. Hard-wired in code.

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/map_continents.pro)</STRONG><P>
<HR>
 
<A NAME="MAVG">
<H2>MAVG</H2></A>
<A HREF="#MAP_CONTINENTS">[Previous Routine]</A>
<A HREF="#NEAREST_ELEMENT.PRO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   MAVG

 PURPOSE:
	This procedure does a &quot;smart average&quot;, where array elements less
	than a certain value are NOT included in the average (they are
	masked out)

 CATEGORY: 
   Array, Math

 CALLING SEQUENCE:
   Result = MAVG( Data, DIMENSION=d, VALUE=v, SUM=s, MASK=m )

 INPUTS:
   Data: This is an array of any dimensions that you want averaged
      across *ONE* of the dimensions

 OPTIONAL INPUTS:
   None
	
 INPUT KEYWORD PARAMETERS:
   DIMENSION: Set this to the dimension across which to sum. The
       first dimension is 1 not 0. The default value is the LAST
       dimension of the input array.

   VALUE: Set this such that any elements LE this value are not
       included in the average. Default is 0.

 OUTPUT KEYWORD PARAMETERS:
   MASK: The mask array used to throw out 'bad' values
   SUM: The sum of the data across the dimension being averaged
 
 OUTPUTS:
   Result: The average of the DATA input array, with any values less
   than VALUE not being included in the average. The DIMENSION of the
   RESULT is one less than the input DATA

 PROCEDURE:
   Yes.

 EXAMPLE:
   data = [ [ 1, 3, 0 ], $   ; 1+3 / 2 = 2
            [ 3, 0, 3 ], $   ; 3+3 / 2 = 3
            [ 0, 0, 10 ] ]   ; 10  / 1  = 10
   ;;; to sum over columns
   avg = MAVG( data, dimension=1 )
   print, avg
        2.00000      3.00000      10.0000

 MODIFICATION HISTORY:
   Written by:	KDM; 2002-07-31
   2002-08-12: KDM; Fixed bug when value gt 0. Made MASK and SUM
	             keyword parameters
   2002-09-05; KDM; made faster when getting rid of elements lt value

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/mavg.pro)</STRONG><P>
<HR>
 
<A NAME="NEAREST_ELEMENT.PRO">
<H2>NEAREST_ELEMENT.PRO</H2></A>
<A HREF="#MAVG">[Previous Routine]</A>
<A HREF="#OAMATH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
    NEAREST_ELEMENT.PRO

 PURPOSE: 
    This function return the nearest element in a LIST to a provided VALUE

 WARNING/NOTE:
    Look at the IDL provided procedure VALUE_LOCATE, as it performs
    a similar function, and works with arrays, and is MUCH
    faster. However, it uses interpolation, so it provides the wrong
    answer sometimes, depending on the type of array passed to it
    IDL&gt; a = [ 0, 1, 1.1, 1.2, 10, 11, 12 ]
    IDL&gt; print, value_locate( a, 1.16 )      ; WRONG
    IDL&gt; print, vaule_locate( a, 9.00 )      ; WRONG
    
    The input array must be fairly linear for VALUE_LOCATE to
    work. If it is not, or has data gaps, use this procedure  
    (NEAREST_ELEMENT)

 CATEGORY: 
    Vector

 CALLING SEQUENCE: 
    result = NEAREST_ELEMENTS( value, list, position )

 INPUTS:
    value: This is a scalar value.
    list:  This is a vector of any type but 'string'

 OUTPUTS: This function returns the element from list that is
     closest to value

 OPTIONAL OUTPUTS: The position into list of the nearest value
     can optionally be returned

 SIDE EFFECTS: hopefully none

 RESTRICTIONS: 
     value cannot be an array
     list must be sequentially increasing

 PROCEDURE: Perform a min(where()) and a max(where()). If multiple
     entries in das_list are equally close, the first entry is returned.

 EXAMPLE:
     val = 42
     list = [ 40, 41, 44, 48 ] ; list = list[sort(list)]
     print, nearest_element( val, list, p ), p
        41    1

 MODIFICATION HISTORY:
    KDM; 2002-04-09; wrote procedure
    KDM; 2002-05-16; documented
    KDM; 2002-07-31; Changed name and code from Mariner 9 DAS
        specific to vector general
    KDM; 2002-08-16; Removed all but 1 where() statement for speed

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/nearest_element.pro)</STRONG><P>
<HR>
 
<A NAME="OAMATH">
<H2>OAMATH</H2></A>
<A HREF="#NEAREST_ELEMENT.PRO">[Previous Routine]</A>
<A HREF="#ORBPAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 ----------------------------------------------------------

 FUNCTION:

   GHA

 PURPOSE:

   Calculates the Greenwich Hour Angle (Right Ascension of 
   the Greenwich Meridian) at the specified time.

 CALLING SEQUENCE:

   GHA (dt)

 INPUT PARAMETERS:

   dt - date/time in standard DT format.

 OPTIONAL KEYWORD PARAMETERS:

   DEGREES - Set to return value in degrees rather than radians

 OUTPUT PARAMETERS:

   GHA (Greenwich Hour Angle in radians, unless /DEGREES keyword is set)

 AUTHOR:

   Jason Westphal 1/98

 ----------------------------------------------------------
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/oamath.pro)</STRONG><P>
<HR>
 
<A NAME="ORBPAR">
<H2>ORBPAR</H2></A>
<A HREF="#OAMATH">[Previous Routine]</A>
<A HREF="#PLOTG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	ORBPAR

 PURPOSE:
	Converts satellite position vectors into orbital parameters

 CALLING SEQUENCE:
	orbpar,utc,r,yd,ut,rs,alt,lat,glat,mlat,lon,mlon,sza,lst,aat
 
 INPUT PARAMETERS:
         utc = array string containing date/ut in format yyyy/ddd-hh:mm:ss.s
         r = array structure containing satellite position vectors in km:
             r.x = x coordinate, double precision
             r.y = y coordinate, double precision
             r.z = z coordinate, double precision
             r.type = type code, integer

 OUTPUT PARAMETERS:
         yd = date, a long integer in yyyyddd format
         ut = universal time in seconds, floating point (0 to 86400)
         rs = distance from center of Earth to satellite, km
         alt = distance from oblate spheroid Earth surface to satellite, km
         lat = geocentric latitude, degrees (-90 to 90)
         glat = geodetic latitude, degrees (-90 to 90)
         mlat = magnetic latitude, degrees (-90 to 90)
         lon  = geocentric longitude, degrees (-180 to 180)
         mlon = magnetic longitude, degrees (-180 to 180)
         sza  = solar zenith angle, degrees (0 to 180)
         lst  = local solar time, hours (0 to 24)
         aat  = angle along track from ascending node, degrees (-180 to 180)
                (note: only calculated if ascending node crossing is in array)

 ROUTINES USED:
	TIMECON - converts date &amp; time into yyyyddd and UT in seconds
	SUNCOR - calculates coordinates of sun and Greenwich sidereal time
	MAGCOORD - approximates magnetic coordinates at 100 km

 AUTHOR:
       Stan Solomon, 4/98

 REFERENCES:
	W.J. Larson &amp; J.R. Wertz, Space Mission Analysis and Design, p. 809
	C.T. Russell, Geophysical Coordinate Transforms.
	A.C. Fraser-Smith, Rev. Geophys., Vol. 25, no. 1, p. 1, 1987
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/orbpar.pro)</STRONG><P>
<HR>
 
<A NAME="PLOTG">
<H2>PLOTG</H2></A>
<A HREF="#ORBPAR">[Previous Routine]</A>
<A HREF="#PLOT_CLEAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	PLOTG

 PURPOSE:
   This procedure is a wrapper for the IDL plot command, that puts a
   light gray grid behind the plot. It makes the plots much easier to
   read :)

 CATEGORY:
   SNOE, plot

 PROCEDURE:
   See PLOT and SNOECT for any and all documentation

 EXAMPLE:
   PLOTG, indgen( 11 )
   PLOTG, indgen(11), title='Foo', GVAL=10

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-07-28
       2002-08-25; KDM; grid is now 'light' even for PS

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/plotg.pro)</STRONG><P>
<HR>
 
<A NAME="PLOT_CLEAR">
<H2>PLOT_CLEAR</H2></A>
<A HREF="#PLOTG">[Previous Routine]</A>
<A HREF="#PLOT_L1">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	PLOT_CLEAR

 PURPOSE:
       Reset system plotting variables

 CATEGORY:
       Plotting

 CALLING SEQUENCE:
       PLOT_CLEAR

 SIDE EFFECTS:
       Resets system plotting variables

 MODIFICATION HISTORY:
 	Written by: KDM; 1998-ish
	2002-09-25: KDM; Added documentation

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/plot_clear.pro)</STRONG><P>
<HR>
 
<A NAME="PLOT_L1">
<H2>PLOT_L1</H2></A>
<A HREF="#PLOT_CLEAR">[Previous Routine]</A>
<A HREF="#RAWVIEW">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	PLOT_L1

 PURPOSE:
       Interactive viewer for Level 1 Data Files

 CATEGORY:
       SNOE, Imaging, Database

 CALLING SEQUENCE:
       PLOT_L1, YYYYDDD

 INPUTS:
       YYYYDDD: The year and day of year of data to view

 KEYWORD PARAMETERS:
       CH:     Set this to 1 or 2 depending on which channel you want
               to view

 EXAMPLE:
       PLOT_L1, 1998070 ; look at the first days worth of data
 
       Standard movie controls are ,.q
       move the mouse.
       colors mean stuff... look at the code

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-08-??
	2002-09-25; KDM; added docs
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/plot_l1.pro)</STRONG><P>
<HR>
 
<A NAME="RAWVIEW">
<H2>RAWVIEW</H2></A>
<A HREF="#PLOT_L1">[Previous Routine]</A>
<A HREF="#RETRIEVE_UVS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	RAWVIEW

 PURPOSE:
       This procedure lets you view Level 0 (a.k.a &quot;raw&quot;) data

 CATEGORY:
       SNOE, analysis, data

 CALLING SEQUENCE:
       RAWVIEW, Data

 INPUTS:
       Data:   A Level 0 Data Structure

 EXAMPLE:
       RETRIEVE_UVS, 2000266, d
       RAWVIEW, d
 
       Use standard MOVIE controls (,.qj) to navigate

 MODIFICATION HISTORY:
 	Written by: KDM; 2002-09-25

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level0/rawview.pro)</STRONG><P>
<HR>
 
<A NAME="RETRIEVE_UVS">
<H2>RETRIEVE_UVS</H2></A>
<A HREF="#RAWVIEW">[Previous Routine]</A>
<A HREF="#SCAT_ANG">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
     RETRIEVE_UVS
       
 PURPOSE:
     Read in one day of UVS Level 0 Data              

 CATEGORY:
     SNOE, Database

 CALLING SEQUENCE:
     RETRIEVE_UVS, YYYYDDD, DATA

 INPUT PARAMETERS:
     YYYYDDD: The Year and Day-of-Year of data to retrieve

 OUTPUT PARAMETERS:
	  DATA = an array of structures

 EXAMPLE:
     RETRIEVE_UVS,1998079,data
     help,data,/st      
 
    ** Structure &lt;1f41c0&gt;, 11 tags, length=544, refs=1:
       VTCW            FLOAT     Array(1)
       REF_HCI         FLOAT     Array(1)
       UTC             STRING    Array[1]
       REF_HCI_XT      STRUCT    -&gt; XT Array[1]
       ID              INT       Array(1)
       HCI_DELAY       INT       Array(1)
       SPR             INT       Array(1)
       INT_DELAY       INT       Array(1)
       INT_PERIOD      INT       Array(1)
       CH_1            FLOAT     Array(65)
       CH_2            FLOAT     Array(65)

 AUTHOR:
      Ken Mankoff

 MODIFICATIONS/REVISION LEVEL:
      Ken Mankoff; 2002-07-30; Wrote it.

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level0/retrieve_uvs.pro)</STRONG><P>
<HR>
 
<A NAME="SCAT_ANG">
<H2>SCAT_ANG</H2></A>
<A HREF="#RETRIEVE_UVS">[Previous Routine]</A>
<A HREF="#SNOECT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 ----------------------------------------------------------

 PROCEDURE:

   SCAT_ANG

 PURPOSE:

   Calculate and return the Solar Phase and Zenith Angles.
   * Solar Phase Angle is the angle between the UVS Line Of Sight
     and the earth sun vector.
   * Solar Zenith Angle is the angle between the spacecraft position
     (zenith) vector and the earth sun vector.

 INPUT PARAMETERS:

   start_date, stop_date =&gt; can be entered in dt or [year, doy, hour, min, sec]

 OPTIONAL KEYWORD PARAMETERS:

   STEPSIZE  =&gt; Time step size in seconds (defaults to 12 seconds)
   UVSTRIG   =&gt; Trigger altitude for UVS in kilometers (defaults to 73 km)
   PLT       =&gt; If Enabled, plots the results

 OUTPUT PARAMETERS:

   state     =&gt; Containing dt, and position/velocity vectors
   spa       =&gt; Solar Phase Angle
   sza       =&gt; Solar Zenith Angle
   latitude  =&gt; Latitude of S/C at each measurement

 AUTHOR:

   Jason Westphal

 LAST UPDATED:

   8/26/98
   3/27/00  

 ----------------------------------------------------------
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/old/scat_ang.pro)</STRONG><P>
<HR>
 
<A NAME="SNOECT">
<H2>SNOECT</H2></A>
<A HREF="#SCAT_ANG">[Previous Routine]</A>
<A HREF="#SNOE_DATE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	SNOECT

 PURPOSE:
	This procedure loads the SNOE color table. It allows different
	variants of the color table based upon keywords, and optionally
	saves the current (about-to-be-destroyed) table.

 CATEGORY:
	SNOE, color, image

 CALLING SEQUENCE:
	SNOECT            ; no *required* args (but plenty o' options)

 INPUTS:
   none

 KEYWORD PARAMETERS:
   GRAY:    Set this keyword to have a gray pixel at index 254
   GVAL:    Set this to the value of the gray pixel [ default: 120 ]
   BW:      Set this keword to swap the Black and White (Top and
            Bottom, Foreground and Backround) 
   DISPLAY: Set this keyword to have the SNOE color table loaded and
            displayed on screen with a color bar and plots of the RGB
            vectors. 

 OPTIONAL OUTPUTS:
   R: The current Red channel vector
   G: The current Green channel vector
   B: The current Blue channel vector

 SIDE EFFECTS:
   The current color table is changed to the SNOE color table.

 RESTRICTIONS:
   You must be able to access the display to call this procedure

 PROCEDURE:
   Generate R,G,B vectors for an 8-bit colortable. Vectors should be
   0 to 255 in length (2^8 = 256). Index 0 should be [0,0,0] which is
   black (background). Index 255 is [255,255,255] which is white
   (foreground) color. Indices between 1 and 254 are the color table
   itself, with the top 2 indices here (253 and 254) repeated as the
   same color. This allows the user to optionally change 254 to any
   shade of gray. 

 EXAMPLE:
   SNOECT  ; load the default SNOE color table
   SNOECT, oldR, oldG, oldB, /gray ; load with gray, save old ct
   SNOECT, /bw ; use for a white background, black text
   SNOECT, /display ; What is the SNOE ct?

   ;;; This is an example how to use gray in you plots
   ;;; I use it to add a subtle grid behind the data
   SNOECT, /gray
   data = indgen(11)
   plot, data, color=254, xticklen=1, yticklen=1
   plot, data, /noerase

 MODIFICATION HISTORY:
   Written by: Ken Mankoff
   05/21/2002; KDM; Added rr,gg,bb, vectors to save current CT. Added
                    /gray, gval, and /bw keywords. Added documentation.
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/snoect.pro)</STRONG><P>
<HR>
 
<A NAME="SNOE_DATE">
<H2>SNOE_DATE</H2></A>
<A HREF="#SNOECT">[Previous Routine]</A>
<A HREF="#SNOE_SUNPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	SNOE_DATE

 PURPOSE:
   This function translates dates for the SNOE S/C and mission,
   between various different formats. 

 CATEGORY:
   SNOE, date, time

 CALLING SEQUENCE:
	result = SNOE_DATE( date, /from_xxx, /to_xxx ) 

 INPUTS:
	Date: a date, in one of the formats listed below.

 KEYWORD PARAMETERS:
       FROM_YMD: A keyword specifing that the input is a 3 element
       vector, where the first element is a four digit year between
       1998 and 2003. The second element is a month number, and the 
       third element is the day-of-month. The year can be either 2 or
       4 digits

       FROM_YYDDD: A keyword specifying that the input is a number
       of the form YYDDD. 20 represents 00020, or day 20 of year 2000.
       98070 is the first day of the mission.

       FROM_YYYYDDD: A keyword specifying that the input is a number
       of the form YYYYDDD. This is a four digit year, followed by a
       3 digit day-of-year.

       FROM_MISSION: A keyword specifying that the input is in day of
       mission format, where zero (0) is the first day of the
       mission.

       FROM_DOM: Same as FROM_MISSION

       FROM_DOY: A keyword specifying that the input is in
       Day-Of-Year format. 1 is the first day of the year.

       FROM_TODAY: This keword makes the output the current UTC date
       converted to the format specified by the /TO_xxx keyword. An
       input argument is OPTIONAL, and will be ignored if this
       keyword is set.

       TO_DOY: A keyword specifying that the output should be the day
       of year of the input date. Note that there is no distinction
       nor way to tell what year this day-of-year belongs to. You
       must deduce this based upon the input.

       TO_YMD: A keyword specifying that the output should be a 3 element
       vector of the form [y,m,d].

       TO_YYDDD: Output is in yyddd format

       TO_YYYYDDD: Output is in yyyyddd format

       TO_MISSION: Output is in day of mission format

       TO_DOM: Same as TO_MISSION

 OUTPUTS:
	    This function returns a number representing the date specified
	    by the /TO_xxx keyword.

 SIDE EFFECTS:
	    Hopefully none.

 RESTRICTIONS:
       Only works through the following dates:
       START: 1998070(yyyyddd), 98070(yyddd), 0(mission), [1998,03,11](ymd)
       STOP: 2003365(yyyyddd), 3365(yyddd), 2121(mission),
       [2003,12,31](ymd)

       Should (?) work if input is [yyyy,1,doy], and keyword from_ymd set.

       NOTE: other undocumented features/bugs may exist. For example,
       ymd input [1999,01,32], and keyword to_ymd set correctly gives the
       output as [1999,02,01]. Or, input 0 and output /TO_DOY gives 365.

 PROCEDURE:
	    The code works by translating ALL input formats (ymd, yyyyddd,
	    doy, etc.) to Day of Mission (or Mission Index, mi). Then, mi
	    is converted to the output requested by the /FROM_xxx keyword.

 EXAMPLE:
       print, snoe_date( [2003,12,31], /from_ymd, /to_mission )
        2121.00
       print, snoe_date( [98,3,11], /from_ymd, /to_yyyyddd )
        1998070
       print, snoe_date( 0, /from_mission, /to_yyyyddd )
        1998070
       print, snoe_date( 0, /from_mi, /to_yyd )  ; UNIQUE keywords!
        98070

 MODIFICATION HISTORY:
 	Written by:	Ken Mankoff, 2001.08.28 (2001240,1266,01240,etc.) 
   09/06/01  TAF;  Added the double keyword so that fractional days
                   can be handled. Only works for from_yyddd and
                   from_yyyyddd for now.
   09/09/01  KDM;  Added Julian day functionality
   09/13/01  KDM;  Added to_doy keyword, added print warning for
                   Julian keyword.  
   09/20/01  KDM;  modified to allow [y,m,d] input to have 2 digit year
   04/23/02  KDM;  Commented out JULIAN functionality. Removed double
                   keyword (see 09/06/01 revision). Fixed 2 digit
                   [y,m,d] error, added comments to code. Added
                   /FROM_TODAY keyword, added /FROM_DOY keyword.
   06/24/02  KDM;  Added DOM (analogous to MISSION)

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/snoe_date.pro)</STRONG><P>
<HR>
 
<A NAME="SNOE_SUNPOS">
<H2>SNOE_SUNPOS</H2></A>
<A HREF="#SNOE_DATE">[Previous Routine]</A>
<A HREF="#TEMPLATE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	SNOE_SUNPOS
 PURPOSE:
	To compute the Earth-Sun vector at a given date.
 CALLING SEQUENCE:
	SNOE_SUNPOS, dt_in, esv [, RA=ra] [, DEC=dec]
 INPUTS:
	dt_in     - Date/time

 OUTPUTS:
       esv       - Earth-to-sun unit vector

 KEYWORDS:

	RA        - Returns the right ascension of the sun
	DEC       - Returns the declination of the sun

 NOTES:
       All angles are represented in radians.

	The user should be aware that the equations used are not highly
	accurate.  The error in right ascension and declination is 0.01
	degrees.

	The results are in the given date's equinox.
 PROCEDURE:
	The solar position is computed using the low precision formulae
	given in the 1993 Astromonical Almanac.
 MODIFICATION HISTORY:
	Written by Michael R. Greason, STX, 28 October 1988.
	Accept vector arguments, W. Landsman     April,1989
	Eliminated negative right ascensions.  MRG, Hughes STX, 6 May 1992.
	Rewritten using the 1993 Almanac.  Keywords added.  MRG, HSTX, 
		10 February 1994.
       Updated by R. Davis, LASP for use on SNOE - 26 Jan 1998
       2002-07-31; KDM; Prepended &quot;SNOE_&quot; to name because of conflicts
</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/uvs/level1/oamath.pro)</STRONG><P>
<HR>
 
<A NAME="TEMPLATE">
<H2>TEMPLATE</H2></A>
<A HREF="#SNOE_SUNPOS">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	TEMPLATE

 PURPOSE:
       This is a template documentation file. Tell what your routine
       does here.  I like to start with the words: &quot;This function (or
       procedure) ...&quot; Try to use the active, present tense. 

 CATEGORY:
	Put a category (or categories) here.  For example:
	SNOE, Imaging, Map, Orbit, Foo

 CALLING SEQUENCE:
	Write the calling sequence here. Include only positional parameters
	(i.e., NO KEYWORDS). For procedures, use the form:

	ROUTINE_NAME, Parameter1, Parameter2, Foobar

	Note that the routine name is ALL CAPS and arguments have Initial
	Caps.  For functions, use the form:
 
	Result = FUNCTION_NAME(Parameter1, Parameter2, Foobar)

	Always use the &quot;Result = &quot; part to begin. This makes it super-obvious
	to the user that this routine is a function!

 INPUTS:
	Parm1:	Describe the positional input parameters here. Note again
		that positional parameters are shown with Initial Caps.

 OPTIONAL INPUTS:
	Parm2:	Describe optional inputs here. If you don't have any, just
		delete this section.
	
 KEYWORD PARAMETERS:
	KEY1:	Document keyword parameters like this. Note that the keyword
		is shown in ALL CAPS!

	KEY2:	Yet another keyword. Try to use the active, present tense
		when describing your keywords.  For example, if this keyword
		is just a set or unset flag, say something like:
		&quot;Set this keyword to use foobar subfloatation. The default
		 is foobar superfloatation.&quot;

 OUTPUTS:
	Describe any outputs here.  For example, &quot;This function returns the
	foobar superflimpt version of the input array.&quot;  This is where you
	should also document the return value for functions.

 OPTIONAL OUTPUTS:
	Describe optional outputs here.  If the routine doesn't have any, 
	just delete this section.

 COMMON BLOCKS:
	BLOCK1:	Describe any common blocks here. If there are no COMMON
		blocks, just delete this entry.

 SIDE EFFECTS:
	Describe &quot;side effects&quot; here.  There aren't any?  Well, just delete
	this entry.

 RESTRICTIONS:
	Describe any &quot;restrictions&quot; here.  Delete this section if there are
	no important restrictions.

 PROCEDURE:
	You can describe the foobar superfloatation method being used here.
	You might not need this section for your routine.

 EXAMPLE:
	Please provide a simple example here. An example from the PICKFILE
	documentation is shown below. Please try to include examples that
       do not rely on variables or data files that are not defined in
       the example code. Your example should execute properly if typed
       in at the IDL command line with no other preparation.

	Create a PICKFILE widget that lets users select only files with 
	the extensions 'pro' and 'dat'.  Use the 'Select File to Read' title 
	and store the name of the selected file in the variable F.  Enter:

		F = PICKFILE(/READ, FILTER = ['pro', 'dat'])

 MODIFICATION HISTORY:
 	Written by:	Your name here, Date.
	2002-03-30: XYZ Made a change. Remember to change the stuff above 
			if you add a new keyword or something!

</PRE><P>
<STRONG>(See /mnt/snoesci/snoe/snoe_sw/template.pro)</STRONG><P>
<HR>
 
</body>
</html>
